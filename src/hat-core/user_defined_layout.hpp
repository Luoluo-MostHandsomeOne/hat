// This source file is part of the 'hat' open source project.
// Copyright (c) 2016, Yuriy Vosel.
// Licensed under Boost Software License.
// See LICENSE.txt for the licence information.

#ifndef _USER_DEFINED_LAYOUT_HPP
#define _USER_DEFINED_LAYOUT_HPP

#include "command_id.hpp"
#include <ostream>
#include <string>
#include <map>
#include <vector>

//The code here is responsible for extracting the infromation from the commands.csv configuration file.

namespace hat {
namespace core {

//If there is no options for this element, an empty space is used as a layout element
//For the list of options, the layout builder will pick up the first one, which is enabled for this environment
struct LayoutElementTemplate
{
	typedef std::vector<CommandID> OptionsContainer;
private:
	OptionsContainer m_optionsForElements;
public:
	LayoutElementTemplate() = default;
	LayoutElementTemplate(std::vector<std::string> const & data)
	{
		m_optionsForElements.reserve(data.size());
		for (auto const & elem : data) {
			m_optionsForElements.push_back(CommandID{ elem });
		}
	}; //TODO: remove this method

	OptionsContainer const & getOptions() const;
	LayoutElementTemplate(std::vector<CommandID> const & data) :m_optionsForElements(data) {};
	static auto create(std::string const & configurationString);
	bool operator == (LayoutElementTemplate const & other) const;
};
std::ostream & operator << (std::ostream & target, LayoutElementTemplate const & toDump);

struct LayoutPageTemplate
{
	typedef std::vector<std::vector<LayoutElementTemplate> > Rows;
private:
	std::string m_name;
	Rows m_rows;
public:

	LayoutPageTemplate(std::string const & note) :m_name(note) {};
	LayoutPageTemplate() = default;

	void decode_and_store_row_description_string(std::string const & row);
	void push_row(std::vector<LayoutElementTemplate> const & rows);
	void push_elem_into_last_row(LayoutElementTemplate const & toAdd);
	Rows const & get_rows() const;

	std::string get_note() const;
	bool operator == (LayoutPageTemplate const & other) const;



	static auto create(std::string const & name);
	static bool isStartOfNewPage(std::string const & name);
	static std::string getNormalPageCaptionFromHeader(std::string const & line);
	static bool isStartOfSelectorPage(std::string const & line);

	struct SelectorPageOptions
	{
		std::string const m_caption;
		CommandID const m_id;
		SelectorPageOptions(std::string const & caption, CommandID const & id) : m_caption(caption), m_id(id) {};
	};
	static SelectorPageOptions getSelectorPageCaptionAndID(std::string const & line);
private:
	static std::string & REQUIRED_PREFIX_() { static auto result = std::string{ "page:" }; return result; }
	static std::string & REQUIRED_OPTIONS_SELECTOR_PREFIX_() { static auto result = std::string{ "optionsSelectorPage:" }; return result; }
};
std::ostream & operator << (std::ostream & target, LayoutPageTemplate const & toDump);


// This class contains all the information about the user-defined part of the layout
// There are also pages, which are generated by this tool automatically(environment selection, commands library). Those are not in this class.
struct LayoutUserInformation
{
	typedef std::map<CommandID, LayoutPageTemplate> OptionsSelctorsContainer;
private:
	std::vector<LayoutPageTemplate> m_layoutPages; // TODO: maybe will switch to std::list, so the references don't get invalidated (more stable code, but currently this feature is not necessary)
	OptionsSelctorsContainer m_optionsSelectionPages;
public:
	std::vector<LayoutPageTemplate> const & getLayoutPages() const;
	void push(LayoutPageTemplate const & toPush);
	void insert_selector_page(CommandID const & id, LayoutPageTemplate const & toInsert);

	LayoutPageTemplate & getCurrentlyLastLayoutPage();
	LayoutPageTemplate & getLayoutPageForOptionSelector(CommandID const & commandID);

	bool contains_selector(CommandID const & commandID) const;
	OptionsSelctorsContainer::const_iterator find_selector(CommandID const & commandID) const;
	OptionsSelctorsContainer::const_iterator non_existent_selector() const;

	static auto parseConfigFile(std::istream & dataToParse);
	bool operator == (LayoutUserInformation const & other) const;
};
} //namespace core
} //namespace hat

#ifdef HAT_CORE_HEADERONLY_MODE
#include "user_defined_layout.cpp"
#endif //HAT_CORE_HEADERONLY_MODE

#endif //_USER_DEFINED_LAYOUT_HPP